## ğŸ“– Overview

The `spotify/` folder hosts everything needed to power the **F1 Stories Podcast** page, including the static HTML template, styling, clientâ€‘side scripts, and serverâ€‘side tools to fetch and update episode metadata. This module enables both a direct Spotify embed solution and an automated RSSâ€‘toâ€‘JSON workflow for dynamic episode loading.

---

## ğŸ—‚ Folder Structure

```
spotify/
â”œâ”€â”€ index.html                # Main podcast page template (HTML + Spotify embed) îˆ€citeîˆ‚turn0file1îˆ
â”œâ”€â”€ podcast.css               # Stylesheet for the podcast page (gradients, cards, responsive layout) îˆ€citeîˆ‚turn0file2îˆ
â”œâ”€â”€ podcast.js                # Clientâ€‘side JavaScript: DOM interactions, embed setup, animations
â”œâ”€â”€ episodes.json             # Cached JSON feed of episodes (schema defined below) îˆ€citeîˆ‚turn0file0îˆ
â”œâ”€â”€ fetch-podcast-episodes.js # Node.js script: fetches RSS, parses episodes, writes `episodes.json`
â””â”€â”€ scheduled-updater.js      # Node.js wrapper: runs `fetch-podcast-episodes.js` on a schedule, logs to `updater.log`
```

---

## ğŸ“„ index.html

* Provides a **Spotify embed** for the show and a **grid container** for episode cards.
* Includes navigation, header (`.podcast-header`), main player (`<iframe>`), episode list placeholder, and subscription CTA.
* Loads `podcast.css` for styling and `podcast.js` for dynamic behavior. îˆ€citeîˆ‚turn0file1îˆ

---

## ğŸ¨ podcast.css

* Defines the **dark, gradient** background for the episode list and header, with subtle pattern overlays.
* Implements **twoâ€‘column** layouts on tablets and singleâ€‘column on mobile.
* Styles `.episode-card`, hover effects, `.episode-title` animations, and navbar scroll behavior.
* Ensures the `.main-player-container` blends smoothly with the page design. îˆ€citeîˆ‚turn0file2îˆ

---

## ğŸ“œ episodes.json

This JSON file serves as a **cache** of podcast metadata, generated by `fetch-podcast-episodes.js`. Its topâ€‘level schema is:

```json
{
  "podcastTitle": "F1 Stories",
  "podcastDescription": "Podcast Î³Î¹Î± Ï„Î·Î½ F1. Î‘Ï€Î»Î¬ ÎºÎ±Î¹ ÏŒÎ¼Î¿ÏÏ†Î±...",
  "podcastImage": "<URL to podcast image>",
  "lastUpdated": "2025-04-15T12:33:50.959Z",
  "episodeCount": 10,
  "episodes": [
    {
      "id": 1,
      "title": "BetCast #4 : Bahrain GP",
      "number": "16",
      "spotifyId": null,
      "description": "Live Î£Ï„Î¿Î¹Ï‡Î·Î¼Î±Ï„Î¹ÎºÎ­Ï‚ Ï€ÏÎ¿Ï„Î¬ÏƒÎµÎ¹Ï‚ Î³Î¹Î± Ï„Î¿ Î´Î¹Î®Î¼ÎµÏÎ¿ !",
      "pubDate": "Mon, 14 Apr 2025 15:52:55 GMT",
      "duration": "00:36:16",
      "audioUrl": "<mp3 URL>",
      "imageUrl": "<episode image URL>",
      "link": "<web link to episode page>"
    },
    â€¦
  ]
}
```

Fields:

* **podcastTitle**, **podcastDescription**, **podcastImage**: show metadata.
* **lastUpdated**: ISO timestamp of the last fetch.
* **episodeCount**: total episodes fetched.
* **episodes**: array of episode objects (see above). îˆ€citeîˆ‚turn0file0îˆ

---

## ğŸš€ Clientâ€‘Side Script: podcast.js

`podcast.js` handles:

1. **Navbar scroll animation**: toggles `.scrolled` class based on `window.scrollY`.
2. **Episode loading**:

    * **Direct Embed Mode**: defines a `latestEpisodes` array with `{ id, title, number }` entries for Spotify episode embeds.
    * Hides the loading spinner (`#episodes-loading`), builds episode cards (`.episode-card`), and alternates between two columns for layouts â‰¥768px.
3. **Interactions**:

    * **Click on card**: highlights the card (`.active`), and updates the main player to the selected episode (`updateMainPlayer`).
4. **Visual flair**:

    * **Particle background** behind the episode grid using generated `<div class="particle">` elements and CSS `@keyframes float`.

To switch to **dynamic mode** using `episodes.json`, modify `loadEpisodesDirectly()` to perform `fetch('episodes.json').then(...)` and map fields accordingly.

---

## âš™ï¸ Serverâ€‘Side Tools

### `fetch-podcast-episodes.js`

* **Purpose**: Fetches the podcast's RSS feed (`https://anchor.fm/s/101588098/podcast/rss`), parses it via [`rss-parser`](https://www.npmjs.com/package/rss-parser), and writes `episodes.json` with the schema above.
* **Usage**:

  ```bash
  npm install rss-parser fs path
  node fetch-podcast-episodes.js
  ```
* **Customizations**:

    * Change `RSS_FEED_URL` for a different source.
    * Adjust the field mapping in the `items.map` callback.

### `scheduled-updater.js`

* **Purpose**: Wraps `fetch-podcast-episodes.js` in a logging mechanism to `updater.log`.
* **Scheduling**: Set up a cron job or a service like `node-cron`. Example:

  ```cron
  # Run daily at 2am
  0 2 * * * cd /path/to/spotify && node scheduled-updater.js
  ```
* **Log Output**: Appends timestamped messages to `updater.log` (create this file or ensure write permissions).

---

## ğŸ Quick Start

1. **Clone** this repo and `cd spotify/`.
2. **Install** server dependencies (for fetching scripts):

   ```bash
   npm install rss-parser fs path
   ```
3. **Generate** or **update** `episodes.json`:

   ```bash
   node fetch-podcast-episodes.js
   ```
4. **Serve** files locally:

   ```bash
   npx http-server . -p 3000
   # or any static file server
   ```
5. **View** at `http://localhost:3000`.

---

## âœ¨ Customization

* **Styling**: Tweak `podcast.css` variables and gradient stops.
* **Embeds**: In `index.html`, change the `<iframe>` `src` to a different Spotify show or playlist.
* **Episode Data**: For manual configuration, update the `latestEpisodes` array in `podcast.js`. For automated updates, rely on `episodes.json` and adjust your fetch logic.

---

## ğŸ›  Troubleshooting

* **No episodes displayed**: Ensure `episodes.json` exists and is valid JSON.
* **CORS errors on fetch**: Run `http-server` (or your host) with CORS enabled if fetching `episodes.json` locally.
* **RSS parse failures**: Verify the feed URL and network connectivity.
* **Permission issues**: Make sure the Node process can write to `episodes.json` and `updater.log`.

---

## ğŸ“˜ License & Contribution

This module follows the same **MIT License** as the main project. Contributions are welcome via PRsâ€”please follow code style and include tests or manual QA for new features.
